{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n\n'use strict';\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread2\";\nvar Info = /*#__PURE__*/_createClass(function Info() {\n  _classCallCheck(this, Info);\n  this.any_blank_count = 0;\n  this.any_blank_ms = 0;\n  this.any_blank_speed_sum = 0;\n  this.mostly_blank_count = 0;\n  this.mostly_blank_ms = 0;\n  this.pixels_blank = 0;\n  this.pixels_sampled = 0;\n  this.pixels_scrolled = 0;\n  this.total_time_spent = 0;\n  this.sample_count = 0;\n});\nvar DEBUG = false;\nvar _listeners = [];\nvar _minSampleCount = 10;\nvar _sampleRate = DEBUG ? 1 : null;\n\n/**\n * A helper class for detecting when the maximem fill rate of `VirtualizedList` is exceeded.\n * By default the sampling rate is set to zero and this will do nothing. If you want to collect\n * samples (e.g. to log them), make sure to call `FillRateHelper.setSampleRate(0.0-1.0)`.\n *\n * Listeners and sample rate are global for all `VirtualizedList`s - typical usage will combine with\n * `SceneTracker.getActiveScene` to determine the context of the events.\n */\nvar FillRateHelper = /*#__PURE__*/function () {\n  function FillRateHelper(getFrameMetrics) {\n    _classCallCheck(this, FillRateHelper);\n    this._anyBlankStartTime = null;\n    this._enabled = false;\n    this._info = new Info();\n    this._mostlyBlankStartTime = null;\n    this._samplesStartTime = null;\n    this._getFrameMetrics = getFrameMetrics;\n    this._enabled = (_sampleRate || 0) > Math.random();\n    this._resetData();\n  }\n  _createClass(FillRateHelper, [{\n    key: \"activate\",\n    value: function activate() {\n      if (this._enabled && this._samplesStartTime == null) {\n        DEBUG && console.debug('FillRateHelper: activate');\n        this._samplesStartTime = global.performance.now();\n      }\n    }\n  }, {\n    key: \"deactivateAndFlush\",\n    value: function deactivateAndFlush() {\n      if (!this._enabled) {\n        return;\n      }\n      var start = this._samplesStartTime; // const for flow\n      if (start == null) {\n        DEBUG && console.debug('FillRateHelper: bail on deactivate with no start time');\n        return;\n      }\n      if (this._info.sample_count < _minSampleCount) {\n        // Don't bother with under-sampled events.\n        this._resetData();\n        return;\n      }\n      var total_time_spent = global.performance.now() - start;\n      var info = _objectSpread(_objectSpread({}, this._info), {}, {\n        total_time_spent: total_time_spent\n      });\n      if (DEBUG) {\n        var derived = {\n          avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,\n          avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),\n          avg_speed_when_any_blank: this._info.any_blank_speed_sum / this._info.any_blank_count,\n          any_blank_per_min: this._info.any_blank_count / (total_time_spent / 1000 / 60),\n          any_blank_time_frac: this._info.any_blank_ms / total_time_spent,\n          mostly_blank_per_min: this._info.mostly_blank_count / (total_time_spent / 1000 / 60),\n          mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent\n        };\n        for (var key in derived) {\n          // $FlowFixMe[prop-missing]\n          derived[key] = Math.round(1000 * derived[key]) / 1000;\n        }\n        console.debug('FillRateHelper deactivateAndFlush: ', {\n          derived: derived,\n          info: info\n        });\n      }\n      _listeners.forEach(function (listener) {\n        return listener(info);\n      });\n      this._resetData();\n    }\n  }, {\n    key: \"computeBlankness\",\n    value: function computeBlankness(props, cellsAroundViewport, scrollMetrics) {\n      if (!this._enabled || props.getItemCount(props.data) === 0 || cellsAroundViewport.last < cellsAroundViewport.first || this._samplesStartTime == null) {\n        return 0;\n      }\n      var dOffset = scrollMetrics.dOffset,\n        offset = scrollMetrics.offset,\n        velocity = scrollMetrics.velocity,\n        visibleLength = scrollMetrics.visibleLength;\n\n      // Denominator metrics that we track for all events - most of the time there is no blankness and\n      // we want to capture that.\n      this._info.sample_count++;\n      this._info.pixels_sampled += Math.round(visibleLength);\n      this._info.pixels_scrolled += Math.round(Math.abs(dOffset));\n      var scrollSpeed = Math.round(Math.abs(velocity) * 1000); // px / sec\n\n      // Whether blank now or not, record the elapsed time blank if we were blank last time.\n      var now = global.performance.now();\n      if (this._anyBlankStartTime != null) {\n        this._info.any_blank_ms += now - this._anyBlankStartTime;\n      }\n      this._anyBlankStartTime = null;\n      if (this._mostlyBlankStartTime != null) {\n        this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;\n      }\n      this._mostlyBlankStartTime = null;\n      var blankTop = 0;\n      var first = cellsAroundViewport.first;\n      var firstFrame = this._getFrameMetrics(first, props);\n      while (first <= cellsAroundViewport.last && (!firstFrame || !firstFrame.inLayout)) {\n        firstFrame = this._getFrameMetrics(first, props);\n        first++;\n      }\n      // Only count blankTop if we aren't rendering the first item, otherwise we will count the header\n      // as blank.\n      if (firstFrame && first > 0) {\n        blankTop = Math.min(visibleLength, Math.max(0, firstFrame.offset - offset));\n      }\n      var blankBottom = 0;\n      var last = cellsAroundViewport.last;\n      var lastFrame = this._getFrameMetrics(last, props);\n      while (last >= cellsAroundViewport.first && (!lastFrame || !lastFrame.inLayout)) {\n        lastFrame = this._getFrameMetrics(last, props);\n        last--;\n      }\n      // Only count blankBottom if we aren't rendering the last item, otherwise we will count the\n      // footer as blank.\n      if (lastFrame && last < props.getItemCount(props.data) - 1) {\n        var bottomEdge = lastFrame.offset + lastFrame.length;\n        blankBottom = Math.min(visibleLength, Math.max(0, offset + visibleLength - bottomEdge));\n      }\n      var pixels_blank = Math.round(blankTop + blankBottom);\n      var blankness = pixels_blank / visibleLength;\n      if (blankness > 0) {\n        this._anyBlankStartTime = now;\n        this._info.any_blank_speed_sum += scrollSpeed;\n        this._info.any_blank_count++;\n        this._info.pixels_blank += pixels_blank;\n        if (blankness > 0.5) {\n          this._mostlyBlankStartTime = now;\n          this._info.mostly_blank_count++;\n        }\n      } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {\n        this.deactivateAndFlush();\n      }\n      return blankness;\n    }\n  }, {\n    key: \"enabled\",\n    value: function enabled() {\n      return this._enabled;\n    }\n  }, {\n    key: \"_resetData\",\n    value: function _resetData() {\n      this._anyBlankStartTime = null;\n      this._info = new Info();\n      this._mostlyBlankStartTime = null;\n      this._samplesStartTime = null;\n    }\n  }], [{\n    key: \"addListener\",\n    value: function addListener(callback) {\n      if (_sampleRate === null) {\n        console.warn('Call `FillRateHelper.setSampleRate` before `addListener`.');\n      }\n      _listeners.push(callback);\n      return {\n        remove: function remove() {\n          _listeners = _listeners.filter(function (listener) {\n            return callback !== listener;\n          });\n        }\n      };\n    }\n  }, {\n    key: \"setSampleRate\",\n    value: function setSampleRate(sampleRate) {\n      _sampleRate = sampleRate;\n    }\n  }, {\n    key: \"setMinSampleCount\",\n    value: function setMinSampleCount(minSampleCount) {\n      _minSampleCount = minSampleCount;\n    }\n  }]);\n  return FillRateHelper;\n}();\nexport default FillRateHelper;","map":{"version":3,"names":["_typeof","o","Symbol","iterator","constructor","prototype","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","_toPropertyKey","key","_createClass","Constructor","protoProps","staticProps","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","call","TypeError","Number","_classCallCheck","instance","_objectSpread","Info","any_blank_count","any_blank_ms","any_blank_speed_sum","mostly_blank_count","mostly_blank_ms","pixels_blank","pixels_sampled","pixels_scrolled","total_time_spent","sample_count","DEBUG","_listeners","_minSampleCount","_sampleRate","FillRateHelper","getFrameMetrics","_anyBlankStartTime","_enabled","_info","_mostlyBlankStartTime","_samplesStartTime","_getFrameMetrics","Math","random","_resetData","value","activate","console","debug","global","performance","now","deactivateAndFlush","start","info","derived","avg_blankness","avg_speed","avg_speed_when_any_blank","any_blank_per_min","any_blank_time_frac","mostly_blank_per_min","mostly_blank_time_frac","round","forEach","listener","computeBlankness","cellsAroundViewport","scrollMetrics","getItemCount","data","last","first","dOffset","offset","velocity","visibleLength","abs","scrollSpeed","blankTop","firstFrame","inLayout","min","max","blankBottom","lastFrame","bottomEdge","blankness","enabled","addListener","callback","warn","push","remove","filter","setSampleRate","sampleRate","setMinSampleCount","minSampleCount"],"sources":["/home/abhilasha/Desktop/Projects/Instagram-clone/node_modules/react-native-web/dist/vendor/react-native/FillRateHelper/index.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n\n'use strict';\n\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread2\";\nclass Info {\n  constructor() {\n    this.any_blank_count = 0;\n    this.any_blank_ms = 0;\n    this.any_blank_speed_sum = 0;\n    this.mostly_blank_count = 0;\n    this.mostly_blank_ms = 0;\n    this.pixels_blank = 0;\n    this.pixels_sampled = 0;\n    this.pixels_scrolled = 0;\n    this.total_time_spent = 0;\n    this.sample_count = 0;\n  }\n}\nvar DEBUG = false;\nvar _listeners = [];\nvar _minSampleCount = 10;\nvar _sampleRate = DEBUG ? 1 : null;\n\n/**\n * A helper class for detecting when the maximem fill rate of `VirtualizedList` is exceeded.\n * By default the sampling rate is set to zero and this will do nothing. If you want to collect\n * samples (e.g. to log them), make sure to call `FillRateHelper.setSampleRate(0.0-1.0)`.\n *\n * Listeners and sample rate are global for all `VirtualizedList`s - typical usage will combine with\n * `SceneTracker.getActiveScene` to determine the context of the events.\n */\nclass FillRateHelper {\n  static addListener(callback) {\n    if (_sampleRate === null) {\n      console.warn('Call `FillRateHelper.setSampleRate` before `addListener`.');\n    }\n    _listeners.push(callback);\n    return {\n      remove: () => {\n        _listeners = _listeners.filter(listener => callback !== listener);\n      }\n    };\n  }\n  static setSampleRate(sampleRate) {\n    _sampleRate = sampleRate;\n  }\n  static setMinSampleCount(minSampleCount) {\n    _minSampleCount = minSampleCount;\n  }\n  constructor(getFrameMetrics) {\n    this._anyBlankStartTime = null;\n    this._enabled = false;\n    this._info = new Info();\n    this._mostlyBlankStartTime = null;\n    this._samplesStartTime = null;\n    this._getFrameMetrics = getFrameMetrics;\n    this._enabled = (_sampleRate || 0) > Math.random();\n    this._resetData();\n  }\n  activate() {\n    if (this._enabled && this._samplesStartTime == null) {\n      DEBUG && console.debug('FillRateHelper: activate');\n      this._samplesStartTime = global.performance.now();\n    }\n  }\n  deactivateAndFlush() {\n    if (!this._enabled) {\n      return;\n    }\n    var start = this._samplesStartTime; // const for flow\n    if (start == null) {\n      DEBUG && console.debug('FillRateHelper: bail on deactivate with no start time');\n      return;\n    }\n    if (this._info.sample_count < _minSampleCount) {\n      // Don't bother with under-sampled events.\n      this._resetData();\n      return;\n    }\n    var total_time_spent = global.performance.now() - start;\n    var info = _objectSpread(_objectSpread({}, this._info), {}, {\n      total_time_spent\n    });\n    if (DEBUG) {\n      var derived = {\n        avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,\n        avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),\n        avg_speed_when_any_blank: this._info.any_blank_speed_sum / this._info.any_blank_count,\n        any_blank_per_min: this._info.any_blank_count / (total_time_spent / 1000 / 60),\n        any_blank_time_frac: this._info.any_blank_ms / total_time_spent,\n        mostly_blank_per_min: this._info.mostly_blank_count / (total_time_spent / 1000 / 60),\n        mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent\n      };\n      for (var key in derived) {\n        // $FlowFixMe[prop-missing]\n        derived[key] = Math.round(1000 * derived[key]) / 1000;\n      }\n      console.debug('FillRateHelper deactivateAndFlush: ', {\n        derived,\n        info\n      });\n    }\n    _listeners.forEach(listener => listener(info));\n    this._resetData();\n  }\n  computeBlankness(props, cellsAroundViewport, scrollMetrics) {\n    if (!this._enabled || props.getItemCount(props.data) === 0 || cellsAroundViewport.last < cellsAroundViewport.first || this._samplesStartTime == null) {\n      return 0;\n    }\n    var dOffset = scrollMetrics.dOffset,\n      offset = scrollMetrics.offset,\n      velocity = scrollMetrics.velocity,\n      visibleLength = scrollMetrics.visibleLength;\n\n    // Denominator metrics that we track for all events - most of the time there is no blankness and\n    // we want to capture that.\n    this._info.sample_count++;\n    this._info.pixels_sampled += Math.round(visibleLength);\n    this._info.pixels_scrolled += Math.round(Math.abs(dOffset));\n    var scrollSpeed = Math.round(Math.abs(velocity) * 1000); // px / sec\n\n    // Whether blank now or not, record the elapsed time blank if we were blank last time.\n    var now = global.performance.now();\n    if (this._anyBlankStartTime != null) {\n      this._info.any_blank_ms += now - this._anyBlankStartTime;\n    }\n    this._anyBlankStartTime = null;\n    if (this._mostlyBlankStartTime != null) {\n      this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;\n    }\n    this._mostlyBlankStartTime = null;\n    var blankTop = 0;\n    var first = cellsAroundViewport.first;\n    var firstFrame = this._getFrameMetrics(first, props);\n    while (first <= cellsAroundViewport.last && (!firstFrame || !firstFrame.inLayout)) {\n      firstFrame = this._getFrameMetrics(first, props);\n      first++;\n    }\n    // Only count blankTop if we aren't rendering the first item, otherwise we will count the header\n    // as blank.\n    if (firstFrame && first > 0) {\n      blankTop = Math.min(visibleLength, Math.max(0, firstFrame.offset - offset));\n    }\n    var blankBottom = 0;\n    var last = cellsAroundViewport.last;\n    var lastFrame = this._getFrameMetrics(last, props);\n    while (last >= cellsAroundViewport.first && (!lastFrame || !lastFrame.inLayout)) {\n      lastFrame = this._getFrameMetrics(last, props);\n      last--;\n    }\n    // Only count blankBottom if we aren't rendering the last item, otherwise we will count the\n    // footer as blank.\n    if (lastFrame && last < props.getItemCount(props.data) - 1) {\n      var bottomEdge = lastFrame.offset + lastFrame.length;\n      blankBottom = Math.min(visibleLength, Math.max(0, offset + visibleLength - bottomEdge));\n    }\n    var pixels_blank = Math.round(blankTop + blankBottom);\n    var blankness = pixels_blank / visibleLength;\n    if (blankness > 0) {\n      this._anyBlankStartTime = now;\n      this._info.any_blank_speed_sum += scrollSpeed;\n      this._info.any_blank_count++;\n      this._info.pixels_blank += pixels_blank;\n      if (blankness > 0.5) {\n        this._mostlyBlankStartTime = now;\n        this._info.mostly_blank_count++;\n      }\n    } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {\n      this.deactivateAndFlush();\n    }\n    return blankness;\n  }\n  enabled() {\n    return this._enabled;\n  }\n  _resetData() {\n    this._anyBlankStartTime = null;\n    this._info = new Info();\n    this._mostlyBlankStartTime = null;\n    this._samplesStartTime = null;\n  }\n}\nexport default FillRateHelper;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}